<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Aplikasi Grafika Komputer 3D</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #0f0f23, #1a1a2e, #16213e);
            font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            position: relative;
        }

        .bg-animation {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            opacity: 0.1;
        }

        .particle {
            position: absolute;
            width: 2px;
            height: 2px;
            background: #64b5f6;
            border-radius: 50%;
            animation: float 6s ease-in-out infinite;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0px) rotate(0deg); opacity: 0; }
            50% { transform: translateY(-100px) rotate(180deg); opacity: 1; }
        }

        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 1000;
            background: rgba(0, 0, 0, 0.85);
            padding: 25px;
            border-radius: 20px;
            backdrop-filter: blur(15px);
            border: 2px solid rgba(100, 181, 246, 0.3);
            max-width: 320px;
            max-height: calc(100vh - 40px);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
            animation: slideInLeft 0.8s ease-out;
            overflow-y: auto;
        }

        #controls::-webkit-scrollbar {
            width: 8px;
        }

        #controls::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
        }

        #controls::-webkit-scrollbar-thumb {
            background: linear-gradient(45deg, #64b5f6, #42a5f5);
            border-radius: 4px;
        }

        @keyframes slideInLeft {
            from { transform: translateX(-100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        #controls h3 {
            color: #64b5f6;
            margin-top: 0;
            margin-bottom: 20px;
            font-size: 20px;
            text-align: center;
            text-shadow: 0 0 10px rgba(100, 181, 246, 0.5);
            animation: glow 2s ease-in-out infinite alternate;
        }

        @keyframes glow {
            from { text-shadow: 0 0 10px rgba(100, 181, 246, 0.5); }
            to { text-shadow: 0 0 20px rgba(100, 181, 246, 0.8), 0 0 30px rgba(100, 181, 246, 0.4); }
        }

        .control-group {
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }

        .control-group:hover {
            background: rgba(255, 255, 255, 0.08);
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(100, 181, 246, 0.2);
        }

        .control-group label {
            display: block;
            color: #ffffff;
            margin-bottom: 8px;
            font-size: 13px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .control-group button {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 10px 15px;
            margin: 3px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .control-group button:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 8px 20px rgba(102, 126, 234, 0.4);
        }

        .control-group button.active {
            background: linear-gradient(45deg, #f093fb, #f5576c);
            box-shadow: 0 0 20px rgba(240, 147, 251, 0.6);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 20px rgba(240, 147, 251, 0.6); }
            50% { box-shadow: 0 0 30px rgba(240, 147, 251, 0.8), 0 0 40px rgba(240, 147, 251, 0.4); }
            100% { box-shadow: 0 0 20px rgba(240, 147, 251, 0.6); }
        }

        input[type="range"] {
            width: 100%;
            margin: 8px 0;
            height: 6px;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
            opacity: 0.7;
            transition: opacity 0.2s;
        }

        input[type="range"]:hover {
            opacity: 1;
        }

        input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(45deg, #64b5f6, #42a5f5);
            cursor: pointer;
            box-shadow: 0 0 10px rgba(100, 181, 246, 0.5);
            transition: all 0.2s ease;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 0 15px rgba(100, 181, 246, 0.8);
        }

        .checkbox-group {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .checkbox-item input[type="checkbox"] {
            transform: scale(1.3);
            accent-color: #64b5f6;
        }

        .checkbox-item label {
            font-size: 12px !important;
            margin-bottom: 0 !important;
            text-transform: none !important;
            letter-spacing: normal !important;
        }

        #info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 20px;
            border-radius: 20px;
            backdrop-filter: blur(15px);
            border: 2px solid rgba(100, 181, 246, 0.3);
            max-width: 320px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
            animation: slideInUp 0.8s ease-out;
        }

        @keyframes slideInUp {
            from { transform: translateY(100%); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        #info h4 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #64b5f6;
            font-size: 16px;
            text-shadow: 0 0 10px rgba(100, 181, 246, 0.5);
        }

        #info p {
            margin: 8px 0;
            font-size: 13px;
            line-height: 1.5;
        }

        #renderer {
            border-radius: 25px;
            overflow: hidden;
            box-shadow: 0 25px 80px rgba(0, 0, 0, 0.4);
            animation: fadeIn 1s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.9); }
            to { opacity: 1; transform: scale(1); }
        }

        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10000;
            text-align: center;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(100, 181, 246, 0.3);
            border-top: 3px solid #64b5f6;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
            width: 100%;
        }

        .file-input-wrapper input[type=file] {
            position: absolute;
            left: -9999px;
        }

        .file-input-label {
            background: linear-gradient(45deg, #4ecdc4, #44a08d);
            color: white;
            padding: 10px 15px;
            border-radius: 10px;
            cursor: pointer;
            display: block;
            text-align: center;
            transition: all 0.3s ease;
            font-size: 12px;
            font-weight: 600;
        }

        .file-input-label:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(78, 205, 196, 0.4);
        }

        body.light-mode {
            background: linear-gradient(135deg, #f8fafc, #e0e7ef, #dbeafe);
            color: #222;
        }

        body.light-mode .bg-animation .particle {
            background: #1976d2;
        }

        body.light-mode #controls,
        body.light-mode #info {
            background: rgba(255, 255, 255, 0.9);
            color: #222;
            border: 2px solid rgba(25, 118, 210, 0.3);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        }

        body.light-mode #controls h3,
        body.light-mode #info h4 {
            color: #1976d2;
            text-shadow: 0 0 10px rgba(25, 118, 210, 0.3);
        }

        body.light-mode #controls label {
            color: #333 !important;
        }

        body.light-mode .control-group {
            background: rgba(0, 0, 0, 0.05);
            border: 1px solid rgba(0, 0, 0, 0.1);
        }

        body.light-mode .control-group button {
            background: linear-gradient(45deg, #42a5f5, #1976d2);
            color: white;
        }

        body.light-mode .control-group button.active {
            background: linear-gradient(45deg, #ff9800, #f57c00);
            box-shadow: 0 0 20px rgba(255, 152, 0, 0.5);
        }

        @media (max-width: 768px) {
            #controls, #info {
                position: relative;
                margin: 20px;
                max-width: none;
                max-height: none;
            }
            
            #controls {
                order: 1;
                max-height: 60vh;
            }
            
            #info {
                order: 2;
            }
            
            #container {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <!-- Loading screen -->
    <div class="loading" id="loading">
        <div class="loading-spinner"></div>
        <p style="color: #64b5f6; margin-top: 15px; font-weight: 600;">Loading 3D Engine...</p>
    </div>

    <!-- Background animation -->
    <div class="bg-animation" id="bgAnimation"></div>

    <div id="container">
        <div id="controls">
            <h3>üéÆ Kontrol 3D</h3>

            <div class="control-group">
                <label>üåì Mode Tampilan:</label>
                <button id="toggleModeBtn" onclick="toggleMode()">üåô Dark Mode</button>
            </div>

            <div class="control-group">
                <label>üé≤ Visualisasi Objek 3D:</label>
                <button onclick="createCube()" class="active" id="cubeBtn">üì¶ Kubus</button>
                <button onclick="createPyramid()" id="pyramidBtn">üî∫ Piramida</button>
                <button onclick="createSphere()" id="sphereBtn">‚öΩ Sphere</button>
            </div>

            <div class="control-group">
                <label>üìÅ Load Model OBJ:</label>
                <div class="file-input-wrapper">
                    <input type="file" id="objFileInput" accept=".obj" onchange="loadOBJFile(event)">
                    <label for="objFileInput" class="file-input-label">üìÇ Load OBJ File</label>
                </div>
            </div>

            <div class="control-group">
                <label>üîÑ Transformasi Objek (Translasi/Rotasi):</label>
                <div>
                    <label>Rotasi X: <span id="rotXValue">0</span>¬∞</label>
                    <input type="range" id="rotX" min="0" max="360" value="0" oninput="updateTransform()" />
                </div>
                <div>
                    <label>Rotasi Y: <span id="rotYValue">0</span>¬∞</label>
                    <input type="range" id="rotY" min="0" max="360" value="0" oninput="updateTransform()" />
                </div>
                <div>
                    <label>Rotasi Z: <span id="rotZValue">0</span>¬∞</label>
                    <input type="range" id="rotZ" min="0" max="360" value="0" oninput="updateTransform()" />
                </div>
                <div>
                    <label>Scale: <span id="scaleValue">1.0</span></label>
                    <input type="range" id="scale" min="0.1" max="3" step="0.1" value="1" oninput="updateTransform()" />
                </div>
                <div>
                    <label>Posisi X: <span id="posXValue">0</span></label>
                    <input type="range" id="posX" min="-5" max="5" step="0.1" value="0" oninput="updateTransform()" />
                </div>
                <div>
                    <label>Posisi Y: <span id="posYValue">0</span></label>
                    <input type="range" id="posY" min="-5" max="5" step="0.1" value="0" oninput="updateTransform()" />
                </div>
                <div>
                    <label>Posisi Z: <span id="posZValue">0</span></label>
                    <input type="range" id="posZ" min="-5" max="5" step="0.1" value="0" oninput="updateTransform()" />
                </div>
            </div>

            <div class="control-group">
                <label>üí° Shading & Pencahayaan (Phong Model):</label>
                <div class="checkbox-group">
                    <div class="checkbox-item">
                        <input type="checkbox" id="ambientLight" checked onchange="updateLighting()" />
                        <label>Ambient Light</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="diffuseLight" checked onchange="updateLighting()" />
                        <label>Diffuse Light</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="specularLight" checked onchange="updateLighting()" />
                        <label>Specular Light</label>
                    </div>
                </div>
            </div>

            <div class="control-group">
                <label>üé• Kamera & Perspektif:</label>
                <button onclick="setProjection('perspective')" class="active" id="perspBtn">üìê gluPerspective</button>
                <button onclick="setProjection('orthographic')" id="orthoBtn">üìè Orthographic</button>
                <button onclick="resetCamera()" id="resetCamBtn">üéØ Reset gluLookAt</button>
            </div>

            <div class="control-group">
                <label>üëÅÔ∏è gluLookAt - Posisi Kamera:</label>
                <div>
                    <label>Eye X: <span id="eyeXValue">5.0</span></label>
                    <input type="range" id="eyeX" min="-10" max="10" step="0.1" value="5" oninput="updateCameraPosition()" />
                </div>
                <div>
                    <label>Eye Y: <span id="eyeYValue">5.0</span></label>
                    <input type="range" id="eyeY" min="-10" max="10" step="0.1" value="5" oninput="updateCameraPosition()" />
                </div>
                <div>
                    <label>Eye Z: <span id="eyeZValue">5.0</span></label>
                    <input type="range" id="eyeZ" min="-10" max="10" step="0.1" value="5" oninput="updateCameraPosition()" />
                </div>
            </div>

            <div class="control-group">
                <label>üìê gluPerspective - Proyeksi 3D:</label>
                <div>
                    <label>Field of View: <span id="fovValue">75</span>¬∞</label>
                    <input type="range" id="fov" min="10" max="120" value="75" oninput="updatePerspective()" />
                </div>
                <div>
                    <label>Near Plane: <span id="nearValue">0.1</span></label>
                    <input type="range" id="nearPlane" min="0.01" max="1" step="0.01" value="0.1" oninput="updatePerspective()" />
                </div>
                <div>
                    <label>Far Plane: <span id="farValue">1000</span></label>
                    <input type="range" id="farPlane" min="10" max="2000" value="1000" oninput="updatePerspective()" />
                </div>
            </div>

            <div class="control-group">
                <label>üé® Rendering:</label>
                <button onclick="toggleWireframe()" id="wireframeBtn">üï∏Ô∏è Wireframe</button>
                <button onclick="toggleShadows()" id="shadowBtn" class="active">üåë Shadows</button>
            </div>
        </div>

        <div id="info">
            <h4>üìã Informasi Grafika 3D</h4>
            <p><strong>Fitur yang Diimplementasikan:</strong></p>
            <p>‚úÖ <strong>Visualisasi Objek 3D:</strong> Kubus, Piramida, Sphere</p>
            <p>‚úÖ <strong>Load File OBJ:</strong> Import model 3D eksternal</p>
            <p>‚úÖ <strong>Transformasi:</strong> Translasi, Rotasi, Scale</p>
            <p>‚úÖ <strong>Shading Phong:</strong> Ambient, Diffuse, Specular</p>
            <p>‚úÖ <strong>Kamera gluLookAt:</strong> Kontrol posisi kamera</p>
            <p>‚úÖ <strong>Proyeksi gluPerspective:</strong> Perspektif 3D</p>
            <p><strong>Kontrol Mouse:</strong></p>
            <p>‚Ä¢ üñ±Ô∏è Klik kiri + drag: Rotasi kamera</p>
            <p>‚Ä¢ üéØ Scroll: Zoom in/out</p>
            <p>‚Ä¢ üëÜ Klik kanan + drag: Pan kamera</p>
            <p><strong>Keyboard:</strong></p>
            <p>‚Ä¢ Space=auto-rotate, R=reset, 1-3=objek</p>
            <p><strong>Status Saat Ini:</strong></p>
            <p id="currentObject">Objek: Kubus</p>
            <p id="currentCamera">Kamera: gluPerspective</p>
            <p id="vertexCount">Vertices: 8</p>
            <p id="shadingModel">Shading: Phong Model</p>
        </div>
    </div>

    <script>
        // Global variables
        let scene, camera, renderer, currentObject;
        let ambientLight, directionalLight, pointLight;
        let currentProjectionMode = "perspective";
        let isWireframe = false;
        let shadowsEnabled = true;
        let autoRotate = true;

        // Mouse controls
        let mouseControls = {
            isMouseDown: false,
            mouseX: 0,
            mouseY: 0,
            cameraAngleX: 0,
            cameraAngleY: 0,
            cameraDistance: 8
        };

        // Camera parameters untuk gluLookAt
        let cameraParams = {
            eyeX: 5.0, eyeY: 5.0, eyeZ: 5.0,
            centerX: 0.0, centerY: 0.0, centerZ: 0.0,
            upX: 0.0, upY: 1.0, upZ: 0.0
        };

        // Perspective parameters untuk gluPerspective
        let perspectiveParams = {
            fov: 75.0,
            aspect: window.innerWidth / window.innerHeight,
            near: 0.1,
            far: 1000.0
        };

        // Implementasi gluLookAt
        function gluLookAt(eyeX, eyeY, eyeZ, centerX, centerY, centerZ, upX, upY, upZ) {
            const eye = new THREE.Vector3(eyeX, eyeY, eyeZ);
            const center = new THREE.Vector3(centerX, centerY, centerZ);
            const up = new THREE.Vector3(upX, upY, upZ);

            camera.position.copy(eye);
            camera.lookAt(center);
            camera.up.copy(up);

            cameraParams = { eyeX, eyeY, eyeZ, centerX, centerY, centerZ, upX, upY, upZ };
        }

        // Implementasi gluPerspective
        function gluPerspective(fov, aspect, near, far) {
            if (currentProjectionMode === "perspective") {
                camera.fov = fov;
                camera.aspect = aspect;
                camera.near = near;
                camera.far = far;
                camera.updateProjectionMatrix();
                perspectiveParams = { fov, aspect, near, far };
            }
        }

        function updateCameraPosition() {
            const eyeX = parseFloat(document.getElementById("eyeX").value);
            const eyeY = parseFloat(document.getElementById("eyeY").value);
            const eyeZ = parseFloat(document.getElementById("eyeZ").value);

            document.getElementById("eyeXValue").textContent = eyeX.toFixed(1);
            document.getElementById("eyeYValue").textContent = eyeY.toFixed(1);
            document.getElementById("eyeZValue").textContent = eyeZ.toFixed(1);

            gluLookAt(eyeX, eyeY, eyeZ, 0, 0, 0, 0, 1, 0);
        }

        function updatePerspective() {
            const fov = parseFloat(document.getElementById("fov").value);
            const near = parseFloat(document.getElementById("nearPlane").value);
            const far = parseFloat(document.getElementById("farPlane").value);
            const aspect = window.innerWidth / window.innerHeight;

            document.getElementById("fovValue").textContent = fov;
            document.getElementById("nearValue").textContent = near.toFixed(2);
            document.getElementById("farValue").textContent = far;

            gluPerspective(fov, aspect, near, far);
        }

        function initBackgroundAnimation() {
            const bgAnimation = document.getElementById('bgAnimation');
            for (let i = 0; i < 50; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.left = Math.random() * 100 + '%';
                particle.style.top = Math.random() * 100 + '%';
                particle.style.animationDelay = Math.random() * 6 + 's';
                bgAnimation.appendChild(particle);
            }
        }

        function toggleMode() {
            const body = document.body;
            const btn = document.getElementById("toggleModeBtn");
            
            body.style.transition = 'all 0.5s ease';
            body.classList.toggle("light-mode");
            
            if (body.classList.contains("light-mode")) {
                btn.textContent = "üåû Light Mode";
                if (scene) scene.background = new THREE.Color(0xf0f8ff);
            } else {
                btn.textContent = "üåô Dark Mode";
                if (scene) scene.background = new THREE.Color(0x0f0f23);
            }
        }

        // Initialize the 3D application
        function init() {
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0f0f23);
            scene.fog = new THREE.Fog(0x0f0f23, 10, 50);

            // Create camera menggunakan gluPerspective
            camera = new THREE.PerspectiveCamera(
                perspectiveParams.fov, 
                perspectiveParams.aspect, 
                perspectiveParams.near, 
                perspectiveParams.far
            );
            
            // Set camera menggunakan gluLookAt
            gluLookAt(
                cameraParams.eyeX, cameraParams.eyeY, cameraParams.eyeZ,
                cameraParams.centerX, cameraParams.centerY, cameraParams.centerZ,
                cameraParams.upX, cameraParams.upY, cameraParams.upZ
            );

            // Create renderer
            renderer = new THREE.WebGLRenderer({ 
                antialias: true, 
                alpha: true,
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.outputEncoding = THREE.sRGBEncoding;
            
            const rendererElement = renderer.domElement;
            rendererElement.id = "renderer";
            document.getElementById("container").appendChild(rendererElement);

            // Setup Shading & Pencahayaan (Phong Model)
            setupPhongLighting();

            // Create ground plane
            createGround();

            // Create initial object - Visualisasi Objek 3D (Kubus)
            createCube();

            // Setup controls
            setupControls();
            
            // Setup keyboard controls
            setupKeyboardControls();

            // Start animation loop
            animate();

            // Handle window resize
            window.addEventListener("resize", onWindowResize);

            // Hide loading screen
            setTimeout(() => {
                document.getElementById('loading').style.display = 'none';
            }, 1500);
        }

        // Implementasi Shading & Pencahayaan (Phong Model)
        function setupPhongLighting() {
            // Ambient Light - komponen ambient dari Phong model
            ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);

            // Directional Light - untuk diffuse dan specular dari Phong model
            directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            
            // Perbaikan shadow settings untuk mengurangi pergerakan aneh
            directionalLight.shadow.mapSize.width = 1024;
            directionalLight.shadow.mapSize.height = 1024;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 20;
            // Kurangi area shadow untuk menghindari shadow terlalu lebar
            directionalLight.shadow.camera.left = -5;
            directionalLight.shadow.camera.right = 5;
            directionalLight.shadow.camera.top = 5;
            directionalLight.shadow.camera.bottom = -5;
            // Bias untuk mengurangi shadow acne
            directionalLight.shadow.bias = -0.0001;
            
            scene.add(directionalLight);

            // Point Light - untuk efek specular tambahan (tidak casting shadow untuk stabilitas)
            pointLight = new THREE.PointLight(0xff6b6b, 0.5, 50);
            pointLight.position.set(5, 5, 5);
            pointLight.castShadow = false; // Disable shadow untuk point light
            scene.add(pointLight);
        }

        function createGround() {
            const groundGeometry = new THREE.PlaneGeometry(20, 20);
            const groundMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x333333,
                transparent: true,
                opacity: 0.8
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -2;
            ground.receiveShadow = true;
            scene.add(ground);
        }

        function setupControls() {
            const canvas = renderer.domElement;

            canvas.addEventListener("mousedown", onMouseDown);
            canvas.addEventListener("mouseup", onMouseUp);
            canvas.addEventListener("mousemove", onMouseMove);
            canvas.addEventListener("wheel", onMouseWheel);
            canvas.addEventListener("contextmenu", (e) => e.preventDefault());

            function onMouseDown(event) {
                mouseControls.isMouseDown = true;
                mouseControls.mouseX = event.clientX;
                mouseControls.mouseY = event.clientY;
                canvas.style.cursor = 'grabbing';
            }

            function onMouseUp() {
                mouseControls.isMouseDown = false;
                canvas.style.cursor = 'grab';
            }

            function onMouseMove(event) {
                if (!mouseControls.isMouseDown) return;

                const deltaX = event.clientX - mouseControls.mouseX;
                const deltaY = event.clientY - mouseControls.mouseY;

                if (event.button === 2) {
                    const panSpeed = 0.01;
                    camera.position.x -= deltaX * panSpeed;
                    camera.position.y += deltaY * panSpeed;
                } else {
                    mouseControls.cameraAngleY += deltaX * 0.01;
                    mouseControls.cameraAngleX += deltaY * 0.01;
                    mouseControls.cameraAngleX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, mouseControls.cameraAngleX));
                    updateCameraOrbit();
                }

                mouseControls.mouseX = event.clientX;
                mouseControls.mouseY = event.clientY;
            }

            function onMouseWheel(event) {
                mouseControls.cameraDistance += event.deltaY * 0.01;
                mouseControls.cameraDistance = Math.max(2, Math.min(30, mouseControls.cameraDistance));
                updateCameraOrbit();
            }

            function updateCameraOrbit() {
                const x = mouseControls.cameraDistance * Math.cos(mouseControls.cameraAngleX) * Math.sin(mouseControls.cameraAngleY);
                const y = mouseControls.cameraDistance * Math.sin(mouseControls.cameraAngleX);
                const z = mouseControls.cameraDistance * Math.cos(mouseControls.cameraAngleX) * Math.cos(mouseControls.cameraAngleY);

                camera.position.set(x, y, z);
                camera.lookAt(0, 0, 0);
            }

            canvas.style.cursor = 'grab';
        }

        function setupKeyboardControls() {
            document.addEventListener('keydown', (event) => {
                switch(event.key.toLowerCase()) {
                    case 'r':
                        resetCamera();
                        break;
                    case ' ':
                        event.preventDefault();
                        autoRotate = !autoRotate;
                        break;
                    case '1':
                        createCube();
                        break;
                    case '2':
                        createPyramid();
                        break;
                    case '3':
                        createSphere();
                        break;
                }
            });
        }

        function resetCamera() {
            cameraParams = {
                eyeX: 5.0, eyeY: 5.0, eyeZ: 5.0,
                centerX: 0.0, centerY: 0.0, centerZ: 0.0,
                upX: 0.0, upY: 1.0, upZ: 0.0
            };

            document.getElementById("eyeX").value = 5.0;
            document.getElementById("eyeY").value = 5.0;
            document.getElementById("eyeZ").value = 5.0;

            updateCameraPosition();

            mouseControls.cameraAngleX = 0;
            mouseControls.cameraAngleY = 0;
            mouseControls.cameraDistance = 8;
        }

        // Visualisasi Objek 3D - Kubus (Manual vertex creation)
        function createCube() {
            removeCurrentObject();
            
            const geometry = new THREE.BoxGeometry(2, 2, 2);
            // Material dengan Phong shading untuk ambient, diffuse, dan specular
            const material = new THREE.MeshPhongMaterial({
                color: 0x64b5f6,
                shininess: 100,  // Specular reflection
                specular: 0x222222,  // Specular color
                wireframe: isWireframe
            });

            currentObject = new THREE.Mesh(geometry, material);
            currentObject.castShadow = true;
            currentObject.receiveShadow = true;
            scene.add(currentObject);

            updateObjectInfo("Kubus", 8, 6);
            setActiveButton("cubeBtn");
        }

        // Visualisasi Objek 3D - Piramida (Manual vertex creation)
        function createPyramid() {
            removeCurrentObject();
            
            const geometry = new THREE.ConeGeometry(1.5, 2.5, 4);
            // Material dengan Phong shading
            const material = new THREE.MeshPhongMaterial({
                color: 0xf093fb,
                shininess: 100,
                specular: 0x222222,
                wireframe: isWireframe
            });

            currentObject = new THREE.Mesh(geometry, material);
            currentObject.castShadow = true;
            currentObject.receiveShadow = true;
            scene.add(currentObject);

            updateObjectInfo("Piramida", 5, 4);
            setActiveButton("pyramidBtn");
        }

        function createSphere() {
            removeCurrentObject();
            
            const geometry = new THREE.SphereGeometry(1.5, 32, 16);
            // Material dengan Phong shading
            const material = new THREE.MeshPhongMaterial({
                color: 0x4ecdc4,
                shininess: 100,
                specular: 0x222222,
                wireframe: isWireframe
            });

            currentObject = new THREE.Mesh(geometry, material);
            currentObject.castShadow = true;
            currentObject.receiveShadow = true;
            scene.add(currentObject);

            updateObjectInfo("Sphere", geometry.attributes.position.count, geometry.index.count / 3);
            setActiveButton("sphereBtn");
        }

        // Load File OBJ
        function loadOBJFile(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const objData = e.target.result;
                    const geometry = parseOBJ(objData);
                    
                    removeCurrentObject();
                    
                    // Material dengan Phong shading untuk file OBJ
                    const material = new THREE.MeshPhongMaterial({
                        color: 0x00bcd4,
                        shininess: 100,
                        specular: 0x222222,
                        wireframe: isWireframe
                    });

                    currentObject = new THREE.Mesh(geometry, material);
                    currentObject.castShadow = true;
                    currentObject.receiveShadow = true;
                    scene.add(currentObject);

                    updateObjectInfo("OBJ Model", geometry.attributes.position.count, geometry.index ? geometry.index.count / 3 : 0);
                } catch (error) {
                    alert("Error loading OBJ file: " + error.message);
                }
            };
            reader.readAsText(file);
        }

        // Simple OBJ parser untuk membaca file OBJ
        function parseOBJ(objData) {
            const vertices = [];
            const faces = [];
            const lines = objData.split('\n');

            for (let line of lines) {
                const parts = line.trim().split(/\s+/);
                if (parts[0] === 'v') {
                    vertices.push(
                        parseFloat(parts[1]),
                        parseFloat(parts[2]),
                        parseFloat(parts[3])
                    );
                } else if (parts[0] === 'f') {
                    for (let i = 1; i < parts.length - 2; i++) {
                        faces.push(
                            parseInt(parts[1].split('/')[0]) - 1,
                            parseInt(parts[i + 1].split('/')[0]) - 1,
                            parseInt(parts[i + 2].split('/')[0]) - 1
                        );
                    }
                }
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setIndex(faces);
            geometry.computeVertexNormals();

            return geometry;
        }

        function removeCurrentObject() {
            if (currentObject) {
                scene.remove(currentObject);
                if (currentObject.geometry) currentObject.geometry.dispose();
                if (currentObject.material) currentObject.material.dispose();
            }
        }

        // Transformasi Objek 3D (Translasi/Rotasi)
        function updateTransform() {
            if (!currentObject) return;

            const rotX = document.getElementById("rotX").value;
            const rotY = document.getElementById("rotY").value;
            const rotZ = document.getElementById("rotZ").value;
            const scale = document.getElementById("scale").value;
            const posX = document.getElementById("posX").value;
            const posY = document.getElementById("posY").value;
            const posZ = document.getElementById("posZ").value;

            // Transformasi rotasi
            currentObject.rotation.x = (rotX * Math.PI) / 180;
            currentObject.rotation.y = (rotY * Math.PI) / 180;
            currentObject.rotation.z = (rotZ * Math.PI) / 180;
            
            // Transformasi scale
            currentObject.scale.setScalar(scale);
            
            // Transformasi translasi
            currentObject.position.set(posX, posY, posZ);

            // Update display values
            document.getElementById("rotXValue").textContent = rotX;
            document.getElementById("rotYValue").textContent = rotY;
            document.getElementById("rotZValue").textContent = rotZ;
            document.getElementById("scaleValue").textContent = parseFloat(scale).toFixed(1);
            document.getElementById("posXValue").textContent = parseFloat(posX).toFixed(1);
            document.getElementById("posYValue").textContent = parseFloat(posY).toFixed(1);
            document.getElementById("posZValue").textContent = parseFloat(posZ).toFixed(1);
        }

        // Update Shading & Pencahayaan (Phong Model)
        function updateLighting() {
            const ambient = document.getElementById("ambientLight").checked;
            const diffuse = document.getElementById("diffuseLight").checked;
            const specular = document.getElementById("specularLight").checked;

            // Control Ambient Light
            ambientLight.visible = ambient;
            
            // Control Diffuse Light (via directional light)
            directionalLight.visible = diffuse;
            
            // Control Specular Light (via point light dan material shininess)
            pointLight.visible = specular;
            
            // Update material properties untuk specular reflection
            if (currentObject && currentObject.material) {
                currentObject.material.shininess = specular ? 100 : 0;
                currentObject.material.specular = specular ? new THREE.Color(0x222222) : new THREE.Color(0x000000);
            }
        }

        // Kamera & Perspektif - Set Projection
        function setProjection(type) {
            const aspect = window.innerWidth / window.innerHeight;

            if (type === "perspective") {
                // Gunakan gluPerspective
                camera = new THREE.PerspectiveCamera(
                    perspectiveParams.fov, 
                    aspect, 
                    perspectiveParams.near, 
                    perspectiveParams.far
                );
                currentProjectionMode = "perspective";
                setActiveButton("perspBtn");
                document.getElementById("currentCamera").textContent = "Kamera: gluPerspective";
            } else {
                // Gunakan orthographic projection
                const frustumSize = 5;
                camera = new THREE.OrthographicCamera(
                    (frustumSize * aspect) / -2, 
                    (frustumSize * aspect) / 2, 
                    frustumSize / 2, 
                    frustumSize / -2, 
                    0.1, 
                    1000
                );
                currentProjectionMode = "orthographic";
                setActiveButton("orthoBtn");
                document.getElementById("currentCamera").textContent = "Kamera: Orthographic";
            }

            // Apply current gluLookAt parameters
            gluLookAt(
                cameraParams.eyeX, cameraParams.eyeY, cameraParams.eyeZ,
                cameraParams.centerX, cameraParams.centerY, cameraParams.centerZ,
                cameraParams.upX, cameraParams.upY, cameraParams.upZ
            );
        }

        function toggleWireframe() {
            isWireframe = !isWireframe;
            if (currentObject && currentObject.material) {
                currentObject.material.wireframe = isWireframe;
            }
            
            const btn = document.getElementById("wireframeBtn");
            if (isWireframe) {
                btn.classList.add("active");
            } else {
                btn.classList.remove("active");
            }
        }

        function toggleShadows() {
            shadowsEnabled = !shadowsEnabled;
            renderer.shadowMap.enabled = shadowsEnabled;
            
            const btn = document.getElementById("shadowBtn");
            if (shadowsEnabled) {
                btn.classList.add("active");
            } else {
                btn.classList.remove("active");
            }
        }

        function setActiveButton(activeId) {
            const objectButtons = ["cubeBtn", "pyramidBtn", "sphereBtn"];
            objectButtons.forEach(id => {
                const btn = document.getElementById(id);
                if (btn) btn.classList.remove("active");
            });
            
            const activeBtn = document.getElementById(activeId);
            if (activeBtn) activeBtn.classList.add("active");
        }

        function updateObjectInfo(name, vertexCount, faceCount) {
            document.getElementById("currentObject").textContent = `Objek: ${name}`;
            document.getElementById("vertexCount").textContent = `Vertices: ${vertexCount}`;
            document.getElementById("shadingModel").textContent = `Shading: Phong Model`;
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            // Auto-rotate object - diperlambat dari 0.005 ke 0.002
            if (currentObject && autoRotate) {
                currentObject.rotation.y += 0.002;
            }

            // Animate point light position dengan pergerakan yang lebih halus dan lambat
            if (pointLight) {
                const time = Date.now() * 0.0008; // Diperlambat dari 0.002 ke 0.0008
                pointLight.position.x = Math.cos(time) * 3; // Kurangi radius dari 4 ke 3
                pointLight.position.z = Math.sin(time) * 3;
                pointLight.position.y = 4 + Math.sin(time * 1.5) * 0.5; // Kurangi variasi Y movement
            }

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            const aspect = window.innerWidth / window.innerHeight;
            
            if (currentProjectionMode === "perspective") {
                gluPerspective(
                    perspectiveParams.fov,
                    aspect,
                    perspectiveParams.near,
                    perspectiveParams.far
                );
            } else {
                const frustumSize = 5;
                camera.left = (frustumSize * aspect) / -2;
                camera.right = (frustumSize * aspect) / 2;
                camera.updateProjectionMatrix();
            }

            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Initialize everything when page loads
        window.addEventListener("load", () => {
            initBackgroundAnimation();
            init();
        });
    </script>
</body>
</html>